---
title: "Transforming Covariates"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Transforming Covariates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

*Built using Zelig version `r packageVersion('Zelig')`*

```{r setup, include=FALSE}
knitr::opts_knit$set(
        stop_on_error = 2L
)
```

##Â Supported transformations

For convenience, you may wish to transform one or more of your covariates within the `zelig` model estimation call. For example, imagine we want to natural log transform the variable `dist` in a linear regression:

```{r, message=FALSE}
library(Zelig)
library(dplyr)

z.log <- zelig(speed ~ log(dist), data = cars, model = 'ls', cite = FALSE)
```

Then we want to find quantities of interest when the `dist` variable is 26 to
56 (the first to third quartile). To do this we added the logged fitted values 
to `setx`, simulate quantities of interest, and plot the results:

```{r}
setx(z.log, dist = log(26:56)) %>%
    sim() %>%
    plot(xlab = 'dist (log)') 
```

## Currently unsupported transformations

The ability to transform covariates in the `zelig` model formula and then set/simulate 
quantities of interest is currently in development. Currently, `zelig` only supports `log` and `as.factor`. 
Interactions are created in the `zelig` call are also evaluated correctly without additional considerations
in `setx`. We aim to introduce more transformations in the future. 

In the meantime. You can transform the covariates outside of the `zelig` model estimation call.
For example, we could start by creating a second order polynomial of the `dist`
variable:

```{r}
cars.poly <- cbind(cars, I(cars$dist^2))
names(cars.poly)[ncol(cars.poly)] <- 'dist_2'

head(cars.poly)
```

Now include this in the `zelig` call and `setx for both the base and second order 
polynomial version of the `dist` variable:

```{r, message=FALSE}
dist_range <- min(cars.poly$dist):max(cars.poly$dist)
zelig(speed ~ dist + dist_2, data = cars.poly, model = 'ls', cite = FALSE) %>%
    setx(dist = dist_range, dist_2 = dist_range^2) %>%
    sim() %>%
    plot()
```

Similarly, we can include splines:

```{r, message=FALSE}
library(splines)
cars.splines <- cbind(cars, bs(cars$dist))
names(cars.splines)[3:5] <- c('dist_bs_1', 'dist_bs_2', 'dist_bs_3')

zelig(speed ~ dist_bs_1 + dist_bs_2 + dist_bs_3, data = cars.splines, 
      model = 'ls', cite = FALSE) %>%
    setx(dist_bs_1 = c(min(cars.splines$dist_bs_1), median(cars.splines$dist_bs_1), 
                       max(cars.splines$dist_bs_2)),
         dist_bs_2 = c(min(cars.splines$dist_bs_2), median(cars.splines$dist_bs_2), 
                       max(cars.splines$dist_bs_2)),
         dist_bs_3 = c(min(cars.splines$dist_bs_3), median(cars.splines$dist_bs_3), 
                       max(cars.splines$dist_bs_3))) %>%
    sim() %>%
    plot()
```

Note that this example was for syntax illustration purposes only. You probably want to use a more continuous range of values for the splines. Make sure that you have an equal number of fitted values for each component of the spline and that these are all in the same order.  

